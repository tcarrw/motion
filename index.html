<!DOCTYPE html>

<html lang="en" data-theme="motion-greens">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Miss Monique · Motion Site</title>
<meta name="description" content="Segment Lab + Showcase for full sets and precision loop editing. Queue builder, tone overlay, notes, check‑ins, and a kiosk display — all in one file." />
<!-- Seed inspiration: earlier Flow Studio structure (internal reference). :contentReference[oaicite:0]{index=0} -->
<style>
  :root{
    --bg:#061512;
    --bg-2:#0a1f1a;
    --fg:#eafff6;
    --fg-dim:#bfeee0;
    --accent:#13c399;        /* motion greens */
    --accent-2:#41e6bf;
    --danger:#ff6b6b;
    --warn:#ffd166;
    --ok:#40ffbe;
    --chip:#0d2b24;
    --glass: color-mix(in sRGB, var(--accent) 10%, #000 82%);
    --glass-2: color-mix(in sRGB, var(--accent) 16%, #000 72%);
    --border: color-mix(in sRGB, var(--accent) 45%, transparent);
    --shadow: 0 10px 32px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.03);
    --radius: 14px;
    --pad: 12px;
    --gap: 12px;
    --focus: color-mix(in sRGB, var(--accent) 78%, white 12%);
  }
  @media (prefers-color-scheme: light){
    :root{
      --bg:#f2fffb; --bg-2:#e9fffb; --fg:#05221a; --fg-dim:#0f4a3d;
      --chip:#ddfff5; --glass:#ffffff; --glass-2:#f7fffd; --shadow: 0 10px 28px rgba(5,20,15,.08), inset 0 1px 0 rgba(0,0,0,.06);
    }
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--fg);
    font:500 16px/1.45 system-ui, -apple-system, Segoe UI, Inter, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
    background:
      radial-gradient(1200px 1200px at 15% -10%, color-mix(in sRGB, var(--accent) 22%, #000 0%), transparent 60%),
      linear-gradient(180deg, #050b0a, var(--bg));
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }
  a{ color: var(--fg-dim); text-decoration:none; border-bottom:1px dotted color-mix(in sRGB, var(--accent) 40%, transparent) }
  .wrap{ max-width:1160px; margin:0 auto; padding:16px; display:grid; gap:var(--gap) }
  .row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap }
  .grow{ flex:1 1 auto }
  .panel{
    border:1px solid var(--border); background:var(--glass);
    border-radius:var(--radius); box-shadow:var(--shadow);
    padding: clamp(12px, 2.6vw, 18px);
  }
  header.header{
    position:sticky; top:0; z-index:8; backdrop-filter: blur(10px) saturate(1.2);
    background: color-mix(in sRGB, var(--accent) 10%, var(--bg-2) 70%);
    border:1px solid var(--border); border-radius: calc(var(--radius) + 6px);
    padding:18px clamp(14px, 3vw, 22px);
  }
  .brand{ font-weight:900; letter-spacing:.2px; font-size:clamp(20px, 3.3vw, 28px) }
  .sub{ opacity:.9 }
  .topbar{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
  .tabs{ display:flex; gap:6px; flex-wrap:wrap }
  button, .btn, input, textarea, select{
    appearance:none; border-radius:12px; border:1px solid var(--border);
    background: color-mix(in sRGB, var(--accent) 8%, #07110f 70%); color:var(--fg);
    padding:9px 12px; font-weight:700;
    transition: transform .16s ease, background .16s ease, border-color .16s ease, box-shadow .16s ease;
    outline:none;
  }
  button:hover{ transform: translateY(-1px) }
  button:active{ transform: translateY(0) scale(.99) }
  button.primary{
    background: linear-gradient(180deg, color-mix(in sRGB, var(--accent) 65%, #fff 5%), color-mix(in sRGB, var(--accent) 35%, #000 10%));
    color:#05241a; border-color: color-mix(in sRGB, var(--accent) 65%, transparent);
  }
  button.ghost{ background: color-mix(in sRGB, var(--accent) 6%, transparent) }
  .tabs [aria-pressed="true"]{ background: color-mix(in sRGB, var(--accent) 24%, #00130f 40%); border-color: color-mix(in sRGB, var(--accent) 70%, transparent) }
  :where(button, .btn, input, textarea, select, [tabindex]):focus{ outline: 2px solid var(--focus); outline-offset:2px }
  .chip{ display:inline-flex; align-items:center; gap:6px; padding:6px 9px; border-radius:999px; border:1px solid var(--border); background:var(--chip); font-size:.86rem }
  .grid{ display:grid; grid-template-columns: 1fr; gap:var(--gap) }
  @media (min-width: 920px){ .grid{ grid-template-columns: 1.1fr .9fr } }
  .kbd{ font-weight:900; padding:2px 7px; border:1px solid var(--border); border-radius:7px; background: color-mix(in sRGB, var(--accent) 12%, transparent) }
  .sr-only{ position:absolute; width:1px; height:1px; margin:-1px; clip:rect(0,0,0,0); overflow:hidden; border:0; padding:0; white-space:nowrap }

/* Player + Timeline */
.player{ border:1px solid var(--border); background:var(--glass-2); border-radius:12px; padding:10px; position:relative; overflow:hidden }
.start-overlay{ position:absolute; inset:0; display:grid; place-items:center; background:linear-gradient(180deg, rgba(0,0,0,.42), rgba(0,0,0,.33)); z-index:3; transition: opacity .2s ease }
.start-overlay.hidden{ opacity:0; pointer-events:none }
.big{ font-size:clamp(15px,2.6vw,18px); padding:14px 16px; border-radius:999px }
.timer{ font-feature-settings:"tnum"; font-variant-numeric:tabular-nums; padding:9px 12px; border-radius:10px; border:1px solid var(--border); background:color-mix(in sRGB, var(--accent) 8%, #07110f 70%); min-width:86px; text-align:center }
.timeline{ position:relative; border:1px solid var(--border); background:#000; border-radius:10px; overflow:hidden }
canvas#wave{ width:100%; height:110px; display:block }
.handle{ position:absolute; top:0; width:10px; height:100%; background: color-mix(in sRGB, var(--accent) 60%, #000 0%); outline: 1px solid color-mix(in sRGB, var(--accent) 70%, transparent); border-right:1px solid rgba(0,0,0,.22); cursor: ew-resize; z-index:2; transform: translateX(-50%) }
.loop-band{ position:absolute; top:0; height:100%; background: color-mix(in sRGB, var(--accent) 12%, rgba(255,255,255,0)); pointer-events:none; z-index:1 }
.playhead{ position:absolute; top:0; width:2px; height:100%; background: var(--accent-2); box-shadow: 0 0 10px color-mix(in sRGB, var(--accent-2) 50%, transparent); z-index:2 }

/* Forms */
.fields{ display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap:8px }
.fields label{ font-size:.8rem; opacity:.9; display:block; margin-bottom:4px }
.half{ grid-column: span 2 }
.wide{ grid-column: 1 / -1 }
textarea{ min-height:86px; resize:vertical }

/* Queue */
.queue{ display:grid; gap:8px }
.q-item{ border:1px solid var(--border); background: color-mix(in sRGB, var(--accent) 7%, #091412 72%); border-radius:12px; padding:10px; display:flex; align-items:center; gap:10px }
.drag{ cursor:grab; user-select:none }
.q-meta{ opacity:.85; font-size:.92rem }
.fav-star{ filter: drop-shadow(0 0 8px rgba(255,255,255,.08)) }

/* Modals */
.modal-back{ position:fixed; inset:0; display:none; place-items:center; background: rgba(0,0,0,.45); z-index:50 }
.modal{ width:min(860px, 92vw); max-height:88vh; overflow:auto; background:var(--glass-2); border:1px solid var(--border); border-radius:16px; box-shadow:var(--shadow); padding:16px }
.modal-back[aria-hidden="false"]{ display:grid }
.modal header{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px }
.close-x{ font-weight:800; padding:6px 9px }

/* Display (Showcase) */
body[data-view="display"] .editor-only{ display:none !important }
.display-wrap{ display:none }
body[data-view="display"] .display-wrap{ display:block }
.living{ border:1px solid var(--border); border-radius:16px; overflow:hidden; background:
radial-gradient(900px 600px at 10% -20%, color-mix(in sRGB, var(--accent) 18%, transparent), transparent 60%),
linear-gradient(180deg, #07110f, #081a15); padding:14px }
.living .now{ font-size:clamp(20px,3vw,26px); font-weight:900; letter-spacing:.3px }
.avatar{ width:44px; height:44px; border-radius:50%; border:1px solid var(--border); background:#0d221d center/cover no-repeat }

/* Self‑Check */
.selfcheck{ position:fixed; bottom:16px; right:16px; z-index:60 }
.check-panel{ display:none; position:fixed; bottom:70px; right:16px; width:min(420px, 92vw); background:var(--glass-2); border:1px solid var(--border); box-shadow:var(--shadow); border-radius:16px; padding:12px; z-index:61 }
.check-panel[aria-hidden="false"]{ display:block }
.check-row{ display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px; border-radius:10px; background: color-mix(in sRGB, var(--accent) 8%, transparent) }
.stat-ok{ color:var(--ok) } .stat-warn{ color:var(--warn) } .stat-bad{ color:var(--danger) }

/* Toast */
.toast{ position:fixed; left:50%; bottom:20px; transform: translateX(-50%); padding:10px 12px; background:var(--chip); border:1px solid var(--border); border-radius:10px; display:none; z-index:70 }
.toast.show{ display:block }

/* Reduced motion */
@media (prefers-reduced-motion:no-preference){
.fade{ animation:fade .2s ease both } @keyframes fade{ from{opacity:0; transform: translateY(2px)} to{opacity:1; transform:none} }
} </style>

</head>
<body tabindex="-1" data-view="editor">
  <div class="wrap">
    <header class="header" role="banner" aria-label="Top bar">
      <div class="row" style="justify-content:space-between; align-items:flex-start">
        <div>
          <div class="brand">Miss Monique · Motion</div>
          <div class="sub">Motion greens for flow, precision loops for focus.</div>
        </div>
        <div class="topbar">
          <div class="tabs" role="tablist" aria-label="Modes">
            <button id="tabGreens"  role="tab" aria-pressed="true"  class="btn ghost">Motion Greens</button>
            <button id="tabWhole"   role="tab" aria-pressed="false" class="btn ghost">Whole Set</button>
            <button id="tabLab"     role="tab" aria-pressed="false" class="btn ghost">Segment Lab</button>
            <button id="tabShow"    role="tab" aria-pressed="false" class="btn ghost">Showcase Page</button>
          </div>
          <div class="grow"></div>
          <button id="btnSelf" class="btn ghost" aria-haspopup="true" aria-expanded="false" title="Open Self‑Check">✓ Self‑Check</button>
          <button id="btnDisplay" class="btn ghost editor-only" aria-pressed="false" title="Toggle Showcase view">Display</button>
        </div>
      </div>
    </header>

```
<main class="grid" role="main">
  <!-- LEFT: Player + Segment Lab -->
  <section class="panel" aria-label="Playback & Editor">
    <!-- Player -->
    <div class="player" aria-label="Player">
      <div class="row" style="justify-content:space-between">
        <div class="row" style="gap:8px">
          <button id="btnStart" class="primary big" aria-label="Start / unlock audio">Start</button>
          <button id="btnPlay" class="btn" aria-label="Play/Pause">Play</button>
          <button id="btnLoop" class="btn ghost" aria-pressed="false" aria-label="Toggle loop">Loop</button>
          <span class="timer" id="timeNow" aria-live="polite">0:00</span>
          <span class="timer" id="timeLeft" aria-live="polite">–0:00</span>
        </div>
        <div class="row" title="Gain (dB)">
          <span>Gain</span>
          <input id="gainDb" type="range" min="-36" max="6" step="1" value="-2" style="width:160px" aria-label="Gain in decibels"/>
          <span id="gainDbVal" class="chip">-2 dB</span>
        </div>
      </div>

      <div class="row" style="margin-top:8px">
        <select id="trackPicker" aria-label="Track select"></select>
        <button id="btnTracks" class="btn ghost editor-only" aria-haspopup="dialog">Tracks Manager</button>
        <div class="chip" id="iosHint" style="display:none">iOS: one tap to unlock audio.</div>
        <div class="grow"></div>
        <label class="chip" for="toneGain"><input id="toneToggle" type="checkbox" /> Tone overlay</label>
        <input id="toneGain" type="range" min="-36" max="-6" step="1" value="-24" style="width:120px" aria-label="Tone gain (dB)" />
      </div>

      <!-- Timeline -->
      <div class="timeline" style="margin-top:10px" aria-label="Waveform timeline with draggable handles">
        <canvas id="wave" role="img" aria-label="Waveform"></canvas>
        <div class="handle" id="hIn"  role="slider" aria-label="In handle"  aria-valuemin="0" aria-valuemax="0" aria-valuenow="0" style="left: 10%"></div>
        <div class="handle" id="hOut" role="slider" aria-label="Out handle" aria-valuemin="0" aria-valuemax="0" aria-valuenow="0" style="left: 60%"></div>
        <div class="loop-band" id="loopBand" style="left:10%; width:50%"></div>
        <div class="playhead" id="playhead" style="left:0%"></div>
        <div class="start-overlay" id="startOverlay">
          <button class="primary big" id="overlayStart" aria-label="Tap to start">Tap to Start</button>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="markIn"  class="btn ghost" title="i">Set In</button>
        <button id="markOut" class="btn ghost" title="o">Set Out</button>
        <div class="grow"></div>
        <span class="chip"><span class="kbd">←</span>/<span class="kbd">→</span> nudge 0.25s</span>
        <span class="chip"><span class="kbd">i</span>/<span class="kbd">o</span> set In/Out</span>
        <span class="chip"><span class="kbd">l</span> loop</span>
      </div>
    </div>

    <!-- Segment Lab editor -->
    <div class="panel" style="margin-top:12px" aria-label="Segment Lab">
      <h2 style="margin:0 0 6px">Segment Lab</h2>
      <div class="fields">
        <div class="half">
          <label for="inTime">In (mm:ss or sec)</label>
          <input id="inTime" type="text" placeholder="0:00" />
        </div>
        <div class="half">
          <label for="outTime">Out (mm:ss or sec)</label>
          <input id="outTime" type="text" placeholder="1:00" />
        </div>
        <div class="half">
          <label for="segName">Name</label>
          <input id="segName" type="text" placeholder="Build / Pocket / Jam" />
        </div>
        <div class="half">
          <label for="segColor">Color tag</label>
          <select id="segColor">
            <option value="#13c399">Emerald Drift</option>
            <option value="#00c2a8">Teal Current</option>
            <option value="#15a87a">Jade Pulse</option>
            <option value="#19e6cb">Verdigris Line</option>
            <option value="#6dd9c5">Seafoam Glow</option>
          </select>
        </div>
        <div class="wide">
          <label for="segNotes">Notes (supports *bold* / _italic_)</label>
          <textarea id="segNotes" placeholder="Cues, drops, phrases…"></textarea>
        </div>
        <div class="row wide" style="justify-content:space-between">
          <label class="chip" style="gap:8px"><input id="favToggle" type="checkbox" /> Favorite</label>
          <div class="row">
            <button id="btnSaveSeg" class="btn">Save Segment (s)</button>
            <button id="btnAddQueue" class="btn ghost">Add to Queue (q)</button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- RIGHT: Queue + Notes + Check‑in -->
  <aside class="panel" aria-label="Queue & Notes">
    <div class="row" style="justify-content:space-between">
      <h2 style="margin:0">Queue</h2>
      <div class="row">
        <button id="btnSaveQueue" class="btn">Save Queue</button>
        <button id="btnClearQueue" class="btn ghost">Clear</button>
      </div>
    </div>
    <div id="queue" class="queue" role="list" aria-label="Queue list"></div>

    <div class="panel" style="margin-top:12px" aria-label="Notes">
      <h3 style="margin:0 0 6px">Notes & Labels</h3>
      <div class="fields">
        <div class="wide">
          <label for="queueNotes">Per‑queue notes</label>
          <textarea id="queueNotes" placeholder="Quick label, cue sheet, mini plan…"></textarea>
        </div>
      </div>
    </div>

    <div class="panel" style="margin-top:12px" aria-label="Check‑In">
      <h3 style="margin:0 0 6px">Check‑In</h3>
      <div class="fields">
        <div>
          <label for="ckEnergy">Energy 0–10</label>
          <input id="ckEnergy" type="range" min="0" max="10" step="1" value="5" aria-valuemin="0" aria-valuemax="10" aria-valuenow="5"/>
        </div>
        <div>
          <label for="ckMood">Mood</label>
          <input id="ckMood" type="text" placeholder="word" />
        </div>
        <div>
          <label for="ckBody">Body</label>
          <select id="ckBody">
            <option>Loose</option>
            <option selected>Neutral</option>
            <option>Tight</option>
          </select>
        </div>
        <div class="wide">
          <label for="ckText">Note</label>
          <input id="ckText" type="text" placeholder="short reflection" />
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="ckLog" class="btn">Log</button>
        <button id="ckExport" class="btn ghost">Export</button>
      </div>
      <canvas id="ckSpark" height="46" style="width:100%; margin-top:8px; border-radius:10px; border:1px solid var(--border); background: color-mix(in sRGB, var(--accent) 6%, transparent)"></canvas>
    </div>

    <div class="row" style="margin-top:12px; justify-content:space-between">
      <div>
        <button id="btnExport" class="btn ghost">Export JSON</button>
        <button id="btnImport" class="btn ghost">Import JSON</button>
      </div>
      <span class="chip"><span class="kbd">?</span> shortcuts</span>
    </div>
  </aside>
</main>

<!-- Showcase (living room) -->
<section class="display-wrap" aria-label="Showcase living room">
  <div class="living panel">
    <div class="row" style="justify-content:space-between">
      <div class="row">
        <div class="avatar" id="displayAvatar" aria-hidden="true"></div>
        <div style="display:grid">
          <div class="now" id="displayNow">—</div>
          <div class="chip" id="displayBadge"><span aria-hidden="true">🔒</span> Locked</div>
        </div>
      </div>
      <div class="row">
        <button id="btnLock" class="btn ghost" title="Quick‑lock editor">Lock</button>
        <button id="btnExitDisplay" class="btn">Exit</button>
      </div>
    </div>
    <div class="row" style="margin-top:10px">
      <div class="timer" id="displayTimer">0:00</div>
      <div class="chip" id="displayMode">Whole Set</div>
    </div>
    <div class="panel" style="margin-top:12px">
      <h3 style="margin:0 0 6px">Up Next</h3>
      <div id="displayQueue" class="queue"></div>
    </div>
  </div>
</section>

<!-- Tracks Manager Modal -->
<div class="modal-back" id="tracksModal" aria-hidden="true" role="dialog" aria-modal="true" aria-label="Tracks Manager">
  <div class="modal">
    <header>
      <strong>Tracks Manager</strong>
      <button class="close-x" data-close="#tracksModal" aria-label="Close">×</button>
    </header>
    <div class="fields">
      <div class="wide">
        <label for="trkTitle">Title</label>
        <input id="trkTitle" type="text" />
      </div>
      <div>
        <label for="trkType">Source type</label>
        <select id="trkType">
          <option value="audio">audio (data: or file)</option>
          <option value="youtube">youtube (metadata only)</option>
        </select>
      </div>
      <div class="half">
        <label for="trkSrc">Source (URL / ID)</label>
        <input id="trkSrc" type="text" placeholder="data:audio/... or YouTube ID" />
      </div>
      <div>
        <label for="trkDur">Duration (sec)</label>
        <input id="trkDur" type="number" min="0" step="1" />
      </div>
      <div>
        <label for="trkBpm">BPM</label>
        <input id="trkBpm" type="number" min="40" max="220" step="1" />
      </div>
      <div>
        <label for="trkKey">Key</label>
        <input id="trkKey" type="text" placeholder="e.g., Am" />
      </div>
    </div>
    <div class="row" style="margin-top:10px">
      <input id="trkFile" type="file" accept="audio/*" style="display:none" />
      <button id="btnPickFile" class="btn ghost">Pick audio file</button>
      <div class="grow"></div>
      <button id="btnAddTrack" class="btn">Add / Update</button>
    </div>
    <div style="margin-top:12px">
      <h3 style="margin:0 0 6px">Your Tracks</h3>
      <div id="tracksList" class="queue" role="list"></div>
    </div>
  </div>
</div>

<!-- Import / Export Modal -->
<div class="modal-back" id="jsonModal" aria-hidden="true" role="dialog" aria-modal="true" aria-label="Import / Export JSON">
  <div class="modal">
    <header>
      <strong>Import / Export</strong>
      <button class="close-x" data-close="#jsonModal" aria-label="Close">×</button>
    </header>
    <textarea id="jsonArea" style="width:100%; min-height:46vh; border-radius:12px; border:1px solid var(--border); background:#000; color:var(--fg)"></textarea>
    <div class="row" style="margin-top:10px; justify-content:space-between">
      <div>
        <button id="btnCopyJson" class="btn">Copy</button>
        <button id="btnLoadJson" class="btn ghost">Load</button>
      </div>
      <span class="chip">All data lives under <strong>mm.motion.v1</strong></span>
    </div>
  </div>
</div>

<!-- Self‑Check -->
<div class="selfcheck">
  <button id="btnSelfFloat" class="btn">✓</button>
</div>
<div id="selfPanel" class="check-panel" aria-hidden="true">
  <div class="row" style="justify-content:space-between; margin-bottom:6px">
    <strong>Self‑Check</strong>
    <button class="close-x" data-close="#selfPanel" aria-label="Close">×</button>
  </div>
  <div id="checkRows" style="display:grid; gap:8px">
    <!-- rows injected -->
  </div>
</div>

<!-- Toast -->
<div id="toast" class="toast" role="status" aria-live="polite" aria-atomic="true"></div>
```

  </div>

  <script>
  "use strict";
  /* ===========================
     Motion Utilities (Part 1/2)
     — small framework, no large data blocks here
  =========================== */

  /* Core DOM helpers */
  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const clamp = (x, a, b) => Math.min(b, Math.max(a, x));
  const lerp  = (a, b, t) => a + (b - a) * t;
  const nowMs = () => performance && performance.now ? performance.now() : Date.now();

  /* Time parse/format */
  function parseTime(v){
    if(typeof v === "number") return v;
    if(!v) return 0;
    const s = String(v).trim();
    if(/^\d+(\.\d+)?$/.test(s)) return parseFloat(s);
    const p = s.split(":").map(x=>x.trim());
    if(p.length===2){ return (+p[0])*60 + (+p[1]); }
    if(p.length===3){ return (+p[0])*3600 + (+p[1])*60 + (+p[2]); }
    return 0;
  }
  function fmtTime(secs){
    secs = Math.max(0, Math.round(secs||0));
    const m = Math.floor(secs/60), s = secs%60;
    return m + ":" + (s<10 ? "0"+s : s);
  }

  /* dB helpers */
  const dbToGain = db => Math.pow(10, (db||0)/20);
  const gainToDb = g => 20 * Math.log10(Math.max(g, 1e-6));

  /* Debounce / Throttle */
  function debounce(fn, ms){ let t=null; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }
  function throttle(fn, ms){ let p=0, s=null; return (...a)=>{ const n=nowMs(); if(n-p>ms){ p=n; fn(...a); } else { clearTimeout(s); s=setTimeout(()=>{ p=nowMs(); fn(...a); }, ms-(n-p)); } }; }

  /* Accessible toast */
  function toast(msg){ const el=$("#toast"); if(!el) return; el.textContent = msg; el.classList.add("show"); setTimeout(()=> el.classList.remove("show"), 2200); }

  /* Safe Local Storage (namespaced) */
  const DB = (function(){
    const ROOT = "mm.motion.v1";
    const def = {
      schemaVersion: 1,
      segments: {},          // id -> {id, trackId, in, out, name, color, fav, notes, createdAt}
      queues: [],            // [{id, name, items:[{type:"segment"|"range", segId/start/end}], notes}]
      notes: {},             // free keyed notes if needed
      settings: { theme:"motion-greens", gainDb:-2, tone:{on:false, db:-24}, crossfadeMs:25, reducedMotion:false, favorites:[] },
      checkins: [],          // [{ts, energy, mood, body, note}]
      tracks: [],            // [{id, title, sourceType, sourceIdOrUrl, durationSec, bpm, key}]
      cache: { waveforms:{} } // trackId -> {w,h, bars: Float32Array serialized to JSON array}
    };
    function read(){ try{ const raw = localStorage.getItem(ROOT); return raw? JSON.parse(raw): JSON.parse(JSON.stringify(def)); }catch(_){ return JSON.parse(JSON.stringify(def)); } }
    function write(obj){ try{ localStorage.setItem(ROOT, JSON.stringify(obj)); }catch(_){ } }
    function get(){ return read(); }
    const save = debounce(write, 120);
    function set(mutator){
      const data = read(); mutator(data); save(data);
      return data;
    }
    return { ROOT, get, set, write, def };
  })();

  /* Event Bus (tiny) */
  const Bus = (()=>{ const map=new Map(); return {
    on:(t,fn)=>{ if(!map.has(t)) map.set(t, new Set()); map.get(t).add(fn); return ()=> map.get(t).delete(fn); },
    emit:(t,p)=>{ if(!map.has(t)) return; map.get(t).forEach(fn=>{ try{ fn(p); }catch(_){ } }); }
  }; })();

  /* Modal helpers */
  function openModal(sel){ const m=$(sel); if(!m) return; m.setAttribute("aria-hidden","false"); document.body.style.overflow="hidden"; }
  function closeModal(sel){ const m=$(sel); if(!m) return; m.setAttribute("aria-hidden","true"); document.body.style.overflow=""; }
  document.addEventListener("click", (e)=>{
    const btn = e.target.closest("[data-close]"); if(btn){ closeModal(btn.getAttribute("data-close")); }
  });

  /* Waveform renderer (bars) */
  const Wave = (function(){
    function analyzePeaks(buffer, widthBars=600){
      const ch = buffer.getChannelData(0);
      const len = ch.length;
      const bars = new Float32Array(widthBars);
      const block = Math.floor(len / widthBars);
      let idx=0;
      for(let i=0;i<widthBars;i++){
        let peak=0, start=i*block, end= Math.min((i+1)*block, len);
        for(let j=start;j<end;j++){ const v=Math.abs(ch[j]); if(v>peak) peak=v; }
        bars[idx++] = peak;
      }
      return bars;
    }
    function draw(canvas, bars, color=getComputedStyle(document.documentElement).getPropertyValue("--accent")){
      if(!canvas || !bars) return;
      const dpr = Math.max(1, Math.floor(window.devicePixelRatio||1));
      const W = canvas.clientWidth, H = canvas.clientHeight;
      canvas.width = W*dpr; canvas.height = H*dpr;
      const ctx = canvas.getContext("2d");
      ctx.scale(dpr, dpr);
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = "#0b0b0b";
      ctx.fillRect(0,0,W,H);
      const n = bars.length;
      const step = W / n;
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0, color);
      g.addColorStop(1, "rgba(255,255,255,0.08)");
      ctx.fillStyle = g;
      const maxH = H - 4;
      for(let i=0;i<n;i++){
        const v = bars[i];
        const h = Math.max(2, v*maxH);
        const x = i*step + 0.8;
        const y = (H - h)/2;
        const w = Math.max(1.2, step * 0.9);
        ctx.fillRect(x, y, w, h);
      }
    }
    return { analyzePeaks, draw };
  })();

  /* Pointer drag for handles */
  function dragX(el, onMove){
    let down=false, rect=null;
    function toPct(clientX){
      const x = clamp(clientX - rect.left, 0, rect.width);
      return x / rect.width;
    }
    el.addEventListener("pointerdown", (e)=>{ down=true; rect=el.parentElement.getBoundingClientRect(); el.setPointerCapture(e.pointerId); onMove(toPct(e.clientX), true); });
    el.addEventListener("pointermove", (e)=>{ if(!down) return; onMove(toPct(e.clientX), false); });
    el.addEventListener("pointerup",   (e)=>{ if(!down) return; down=false; onMove(toPct(e.clientX), false, true); });
  }

  /* High‑precision clock for UI */
  const Clock = (function(){
    let last=0, rafId=0, subs=new Set();
    function tick(t){
      if(!last) last=t;
      subs.forEach(fn=>{ try{ fn(t); }catch(_){ } });
      rafId = requestAnimationFrame(tick);
    }
    function start(){ if(rafId) return; rafId = requestAnimationFrame(tick); }
    function stop(){ cancelAnimationFrame(rafId); rafId=0; last=0; }
    return { start, stop, on:(fn)=>{ subs.add(fn); return ()=>subs.delete(fn); } };
  })();

  /* Audio Engine (scheduler + tone overlay) */
  const Engine = (function(){
    const S = {
      ctx:null, unlocked:false,
      master:null, gain:null, tone:{ osc:null, gain:null, on:false },
      current: null,        // current scheduled node
      playing:false, startAt:0, whenCtxStart:0, // timeline
      track:{ id:null, buffer:null, duration:0 },
      loop:{ on:false, a:0, b:0 },
      xfMs:25,
      listeners:new Set()
    };

    function ensure(){
      if(S.ctx) return;
      try{
        const ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint:'interactive' });
        const master = ctx.createGain();
        const gain = ctx.createGain();
        const toneGain = ctx.createGain();
        const osc = ctx.createOscillator();
        osc.type = "sine"; osc.frequency.value = 110; // gentle low A
        toneGain.gain.value = 0.0; osc.connect(toneGain);
        toneGain.connect(master);
        gain.connect(master); master.connect(ctx.destination);
        osc.start();

        S.ctx = ctx; S.master = master; S.gain = gain;
        S.tone.osc = osc; S.tone.gain = toneGain;
      }catch(_){ }
    }

    async function unlock(){
      ensure();
      if(!S.ctx) return false;
      if(S.ctx.state === "suspended"){
        try{ await S.ctx.resume(); }catch(_){}
      }
      S.unlocked = S.ctx && S.ctx.state === "running";
      return S.unlocked;
    }

    function setGainDb(db){
      if(!S.gain) return;
      S.gain.gain.setTargetAtTime(dbToGain(db), S.ctx.currentTime, 0.015);
    }
    function setTone(on, db){
      S.tone.on = !!on;
      if(!S.tone.gain) return;
      const target = on ? dbToGain(db) : 0.0;
      S.tone.gain.gain.setTargetAtTime(target, S.ctx.currentTime, 0.02);
    }
    function setCrossfade(ms){
      S.xfMs = clamp(ms|0, 5, 50);
    }

    function connectBuffer(buf){
      const src = S.ctx.createBufferSource();
      src.buffer = buf;
      const g = S.ctx.createGain();
      g.gain.value = 1;
      src.connect(g).connect(S.gain);
      return { src, g };
    }

    function time(){ return S.playing ? (S.ctx.currentTime - S.whenCtxStart + S.startAt) : S.startAt; }

    function scheduleSegment(start, end, loop){
      if(!S.track.buffer) return;
      killCurrent();
      const a = clamp(start, 0, S.track.duration);
      const b = clamp(end, a, S.track.duration);
      const { src, g } = connectBuffer(S.track.buffer);
      const now = S.ctx.currentTime;
      const dur = (b - a);
      const xf = Math.min(S.xfMs/1000, Math.max(0.005, dur*0.05));
      g.gain.setValueAtTime(0.0, now);
      g.gain.linearRampToValueAtTime(1.0, now + xf);

      src.start(now, a, dur + 0.010); // small pad
      if(loop){
        // fade out near end, then restart
        const tEnd = now + dur;
        g.gain.setValueAtTime(1.0, tEnd - xf);
        g.gain.linearRampToValueAtTime(0.0, tEnd + 0.002);
        src.stop(tEnd + 0.010);
        S.current = { src, g, a, b, loop:true };
        // schedule loop jump
        setTimeout(()=>{ if(S.current && S.current.loop){ scheduleSegment(a, b, true); } }, Math.max(0, (dur*1000) - 6));
      }else{
        // graceful end
        const tEnd = now + dur;
        g.gain.setValueAtTime(1.0, tEnd - xf);
        g.gain.linearRampToValueAtTime(0.0, tEnd + 0.002);
        src.stop(tEnd + 0.010);
        S.current = { src, g, a, b, loop:false };
        setTimeout(()=> stop(), Math.max(0, (dur*1000) - 6));
      }
      S.playing = true; S.whenCtxStart = now; S.startAt = a;
      Bus.emit("engine:play", {start:a, end:b, loop:!!loop});
    }

    function stop(){
      if(!S.ctx) return;
      killCurrent();
      S.playing = false;
      Bus.emit("engine:stop");
    }
    function killCurrent(){
      if(S.current){
        try{ S.current.src.stop(); }catch(_){}
        try{ S.current.g.disconnect(); }catch(_){}
      }
      S.current = null;
    }

    function loadBuffer(buffer, trackId){
      S.track.id = trackId || "buf";
      S.track.buffer = buffer;
      S.track.duration = buffer.duration|0;
      Bus.emit("engine:loaded", { id:S.track.id, duration:S.track.duration, buffer });
    }

    return {
      S, unlock, ensure, setGainDb, setTone, setCrossfade, scheduleSegment, stop, time, loadBuffer
    };
  })();

  /* Sparkline (check‑ins) */
  function drawSpark(canvas, points){
    if(!canvas) return;
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio||1));
    const W = canvas.clientWidth, H = canvas.height;
    canvas.width = W*dpr; const ctx = canvas.getContext("2d");
    ctx.scale(dpr, 1);
    ctx.clearRect(0,0,W,H);
    const pad = 8, n = points.length||0;
    if(!n){ ctx.fillStyle="rgba(255,255,255,.2)"; ctx.fillRect(0,0,W,H); return; }
    const max = 10, min = 0;
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue("--accent");
    ctx.lineWidth = 2;
    ctx.beginPath();
    points.forEach((v,i)=>{
      const x = pad + (W-pad*2) * (i/(n-1||1));
      const y = (H-pad) - ( (v-min)/(max-min) ) * (H-pad*2);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.stroke();
  }

  /* Keyboard map scaffolding (actual wiring in Part 2) */
  const Keys = {
    SPACE:" ", I:"i", O:"o", L:"l",
    LEFT:"ArrowLeft", RIGHT:"ArrowRight", UP:"ArrowUp", DOWN:"ArrowDown",
    S:"s", Q:"q",
    DIGIT:(n)=> String(n|0)
  };

  /* Reduced motion honor (UI only) */
  try{
    if(window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches){
      document.querySelectorAll("*").forEach(el=>{ el.style.transitionDuration = "0s"; });
      DB.set(d=>{ d.settings.reducedMotion = true; });
    }
  }catch(_){}

  /* Non‑blocking, visible focus on body for shortcuts */
  function focusForShortcuts(){ try{ document.body.focus({preventScroll:true}); }catch(_){ } }
  document.addEventListener("pointerdown", (e)=>{ if(!e.target.closest("input,textarea,select,[contenteditable=true]")) focusForShortcuts(); }, true);

  /* Basic UI holders (logic continues in Part 2) */
  const UI = {
    els:{
      wave: $("#wave"), hIn:$("#hIn"), hOut:$("#hOut"), band:$("#loopBand"), playhead:$("#playhead"),
      btnStart:$("#btnStart"), overlayStart:$("#overlayStart"), startOverlay:$("#startOverlay"),
      btnPlay:$("#btnPlay"), btnLoop:$("#btnLoop"),
      timeNow:$("#timeNow"), timeLeft:$("#timeLeft"),
      gainDb:$("#gainDb"), gainDbVal:$("#gainDbVal"),
      toneToggle:$("#toneToggle"), toneGain:$("#toneGain"),
      trackPicker:$("#trackPicker"),
      markIn:$("#markIn"), markOut:$("#markOut"),
      inTime:$("#inTime"), outTime:$("#outTime"), segName:$("#segName"), segColor:$("#segColor"), segNotes:$("#segNotes"), favToggle:$("#favToggle"),
      btnSaveSeg:$("#btnSaveSeg"), btnAddQueue:$("#btnAddQueue"),
      queue:$("#queue"), btnSaveQueue:$("#btnSaveQueue"), btnClearQueue:$("#btnClearQueue"), queueNotes:$("#queueNotes"),
      ckEnergy:$("#ckEnergy"), ckMood:$("#ckMood"), ckBody:$("#ckBody"), ckText:$("#ckText"), ckLog:$("#ckLog"), ckExport:$("#ckExport"), ckSpark:$("#ckSpark"),
      btnTracks:$("#btnTracks"), tracksModal:"#tracksModal", btnPickFile:$("#btnPickFile"), trkFile:$("#trkFile"),
      trkTitle:$("#trkTitle"), trkType:$("#trkType"), trkSrc:$("#trkSrc"), trkDur:$("#trkDur"), trkBpm:$("#trkBpm"), trkKey:$("#trkKey"), btnAddTrack:$("#btnAddTrack"), tracksList:$("#tracksList"),
      btnExport:$("#btnExport"), btnImport:$("#btnImport"), jsonModal:"#jsonModal", jsonArea:$("#jsonArea"), btnCopyJson:$("#btnCopyJson"), btnLoadJson:$("#btnLoadJson"),
      btnSelf:$("#btnSelf"), btnSelfFloat:$("#btnSelfFloat"), selfPanel:"#selfPanel", checkRows:$("#checkRows"),
      tabGreens:$("#tabGreens"), tabWhole:$("#tabWhole"), tabLab:$("#tabLab"), tabShow:$("#tabShow"),
      btnDisplay:$("#btnDisplay"), btnExitDisplay:$("#btnExitDisplay"), btnLock:$("#btnLock"), displayQueue:$("#displayQueue"),
      displayNow:$("#displayNow"), displayBadge:$("#displayBadge"), displayTimer:$("#displayTimer"), displayMode:$("#displayMode")
    },
    state:{
      dragging:null, dragA:0.1, dragB:0.6, duration:0, playMs:0
    }
  };

  /* Handle drags — just update visuals here; binding to engine occurs in Part 2 */
  dragX(UI.els.hIn, (pct)=>{ UI.state.dragA = Math.min(pct, UI.state.dragB - 0.005); layoutLoopBand(); });
  dragX(UI.els.hOut,(pct)=>{ UI.state.dragB = Math.max(pct, UI.state.dragA + 0.005); layoutLoopBand(); });
  function layoutLoopBand(){
    const a = UI.state.dragA, b = UI.state.dragB;
    UI.els.hIn.style.left = (a*100)+"%";
    UI.els.hOut.style.left = (b*100)+"%";
    UI.els.band.style.left = (a*100)+"%";
    UI.els.band.style.width = ((b-a)*100)+"%";
  }
  layoutLoopBand();

  /* Self‑Check UI rows scaffold (tests run in Part 2) */
  function setCheckRow(id, label, status, hint){
    let row = $("#row_"+id);
    if(!row){
      row = document.createElement("div");
      row.className="check-row fade"; row.id = "row_"+id;
      row.innerHTML = `<div>${label}</div><div class="chip"><span class="stat">—</span></div>`;
      UI.els.checkRows.appendChild(row);
    }
    const stat = $(".stat", row);
    if(status==="ok"){ stat.textContent="OK"; stat.className="stat stat-ok"; }
    else if(status==="warn"){ stat.textContent="Check"; stat.className="stat stat-warn"; }
    else if(status==="bad"){ stat.textContent="Fail"; stat.className="stat stat-bad"; }
    if(hint){ row.title = hint; }
  }

  /* Open/close helpers */
  $("#btnSelf").addEventListener("click", ()=>{ const p=$(UI.els.selfPanel); const v = p.getAttribute("aria-hidden")!=="false"; p.setAttribute("aria-hidden", String(!v)); });
  $("#btnSelfFloat").addEventListener("click", ()=>{ const p=$(UI.els.selfPanel); const v = p.getAttribute("aria-hidden")!=="false"; p.setAttribute("aria-hidden", String(!v)); });
  $("#btnTracks").addEventListener("click", ()=> openModal(UI.els.tracksModal));
  $("#btnExport").addEventListener("click", ()=> openModal(UI.els.jsonModal));
  $("#btnImport").addEventListener("click", ()=> openModal(UI.els.jsonModal));

  /* Start/unlock overlay buttons wire basic unlock only; full init in Part 2 */
  $("#btnStart").addEventListener("click", async ()=>{
    const ok = await Engine.unlock();
    if(ok){ $("#btnStart").disabled = true; $("#overlayStart")?.click(); toast("Audio unlocked"); }
  });
  $("#overlayStart").addEventListener("click", async ()=>{
    const ok = await Engine.unlock();
    if(ok){ const ov=$(".start-overlay"); if(ov) ov.classList.add("hidden"); toast("Ready"); }
  });

  /* Live gain/tone controls (engine must exist) */
  $("#gainDb").addEventListener("input", (e)=>{ const v = parseInt(e.target.value,10); $("#gainDbVal").textContent = v+" dB"; Engine.setGainDb(v); DB.set(d=>{ d.settings.gainDb = v; }); });
  $("#toneToggle").addEventListener("change", (e)=>{ const on = !!e.target.checked; const dB = parseInt($("#toneGain").value,10); Engine.setTone(on, dB); DB.set(d=>{ d.settings.tone.on = on; d.settings.tone.db = dB; }); });
  $("#toneGain").addEventListener("input", (e)=>{ const dB = parseInt(e.target.value,10); const on = $("#toneToggle").checked; Engine.setTone(on, dB); DB.set(d=>{ d.settings.tone.db = dB; }); });

  /* Clock paints playhead only (timeline binding in Part 2) */
  Clock.on(()=>{ const dur = UI.state.duration||1; const t = clamp(Engine.time()/dur, 0, 1); UI.els.playhead.style.left = (t*100)+"%"; });
  Clock.start();

  /* Theme load */
  (function restoreTheme(){
    const st = DB.get().settings; document.documentElement.setAttribute("data-theme", st.theme || "motion-greens");
    $("#gainDb").value = String(st.gainDb|0); $("#gainDbVal").textContent = (st.gainDb|0)+" dB";
    $("#toneToggle").checked = !!(st.tone && st.tone.on);
    $("#toneGain").value = String(st.tone ? (st.tone.db|0) : -24);
  })();

  /* Keyboard focus & help badge (full bindings in Part 2) */
  window.addEventListener("keydown", (e)=>{
    const active = document.activeElement;
    const typing = active && (/(INPUT|TEXTAREA|SELECT)/.test(active.tagName) || active.isContentEditable);
    if(typing) return;
    if(e.key === "?"){ e.preventDefault(); toast("Space: play • i/o: set • l: loop • ←/→: nudge • ↑/↓: gain ±1dB • s: save seg • q: to queue • 1–9: favorites"); }
  }, true);

  /* Screen reader hints for iOS */
  (function iosHint(){ try{
    const ua = navigator.userAgent||"";
    if(/iPhone|iPad|iPod/i.test(ua)){ const el=$("#iosHint"); if(el) el.style.display="inline-flex"; }
  }catch(_){}})();

  /* Expose small API for Part 2 to extend */
  window.MotionCore = { DB, Bus, Engine, Wave, Keys, drawSpark, fmtTime, parseTime, clamp, toast, openModal, closeModal, UI, setCheckRow };
  </script>

<!-- SPLIT_TOKEN:MISS_MONIQUE_MOTION_v1 -->



<!-- FILE_ID: MISS_MONIQUE_MOTION / BUILD: v1 / PART: 2of2 -->

<script>
/* =========================================================
   Motion Logic (Part 2/2)
   Data, playback logic, persistence, keyboard, self‑check.
   Seed scaffold drew on a prior “Flow Studio” internal ref. :contentReference[oaicite:0]{index=0}
========================================================= */
(function(){
  "use strict";
  const M = window.MotionCore;
  const UI = M.UI;

  /* ---------- Large data: tiny royalty‑free demo tone (1.2s, 110Hz) ---------- */
  const DEMO_DATA_URL = "data:audio/wav;base64,"+
"UklGRqQlAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YYAlAACAhImOk5ecoKSoq66xs7W3ub3C" +
"x8rJx8a3vbe6ubOooX5uZWRWTUo1KSIaFxQQDgkGBQQDBAQFBgkNExwmLS9BRU9jbnR/gIR7e3Z0b2VnZGRf" +
"XFVPSkQ9OC0nJR4bGRQRCgkIBQUDBAQFBwgNDxwdJC0zOUNGR1Rjbm9/foSDfnt3dW9nZ2ZfXlZQTUhFOTMu" +
"KSYfGxkUEQoJCAcGBAQEBQcJDQ8dHSQtMztBQUZUY25vf36Eg35+d3Vvb2dnaF9eV1BOS0ZBOzcpJh8bGRUR" +
"CgkIBwYFBAQFBwkNEB0dIy0zO0FBRVNjb291f4SDf353dW9uZ2doX15XUE5LRkE7NyknHxwZFBELCggHBQQE" +
"BQYJDRAdHSItMzxBQ0dUY29xfoCEf353dG9uZ2dgX1xXT05LRUE8NyknHxsYFBELCggHBgUEBAUGCA0QHR0i" +
"LTQ8QURHVGNvcX6AhH99e3RvbmhnYF9cV05OS0ZBPDcpKB8cGBQRCwoIBwYFBAQFBggNEB0dIS40PEFER1Vj" +
"cHF+gIR/fXt0bmloaGBdV1ZOSEZBPDgpKB8cGRUREQoJCAcGBQQEBQYIDRAdHSEsNDw/RURVV2Nzcn6AhH99" +
"e3RtamlpYF1XVk5IRkE9OCkoHyAZFRERCgkIBwYFBAQFBggNEBwcISw0P0BFVVdjc3J+gIR/fXt0bWppaGBd" +
"V1ZOSUZBPTYoKB8gGRURCwoIBwYFBAQFBgkNEBwbISw0P0BFVVdjcnJ+f4N/fnpzbWppaGJdVlZPSUdAPTUo" +
"KB8gGRURCwoIBwYFBAQFBgkNEBsbISw0P0FGVVdjc3N+f4N+fnpzbWppaGJdVlZPSUdAPTUoKB8gGRURCwoI" +
"BwYFBAQFBgkNEBsbISw0P0FGVVdjc3N+f4N+fnpzbWppaGJdVlZPSUdAPTUoKB8gGRURCwoIBwYFBAQFBgkN" +
"EBsbISw0P0FGVVdjc3N+f4N+fnpzbWppaGJdVlZPSUdAPTUoKB8gGRURCwoIBwYFBAQFBgkNEBsbISw0P0FG" +
"VVdjc3N+f4N+fnpzbWppaGJdVlZPSUdAPTUoKB8gGRURCwoIBwYFBAQFBgkNEBsbISw0P0FGVVdjc3N+f4N+" +
"fnpzbWppaGJdVlZPSUdAPTUoKB8gGRURCwoIBwYFBAQFBgkNEBsbISw0P0FGVVdjc3N+f4N+fnpzbWppaGJd" +
"VlZPSUdAPTUoKB8gGRURCwoIBwYFBAQFBgkNEBsbISw0P0FGVVdjc3N+f4N+fnpzbWppaGJdVlZPSUdAPTUo" +
"KB8gGRURCwoIBwYFBAQFBgkNEBsbISw0P0FGVVdjc3N+f4N+fnpzbWppaGJdVlZPSUdAPTUoKB8gGRURCwoI" +
"BwYFBAQFBgkNEBsbISw0P0FGVVdjc3N+f4N+fnpzbWppaGJdVlZPSUdAPTUoKB8gGRURCwoIBwYFBAQFBgkN" +
"EBsbISw0P0FGVVdjc3N+f4N+fnpzbWppaGJdVlZPSUdAPQ==";

  /* ---------- Schema & initial content ---------- */
  function guid(){ return "seg_"+Math.random().toString(36).slice(2,9); }
  function ensureDemo(){
    M.DB.set(d=>{
      if(!d.tracks || !d.tracks.length){
        d.tracks = [{
          id:"demo_tone",
          title:"Demo Tone — 110Hz",
          sourceType:"audio",
          sourceIdOrUrl: DEMO_DATA_URL,
          durationSec: 1,
          bpm: 110,
          key: "A"
        }];
      }
      if(!d.settings) d.settings = M.DB.def.settings;
      if(!d.notes) d.notes = {};
      if(!d.notes.bee){
        d.notes.bee = {
          ts: Date.now(),
          text: "🐝 Bee note — think about Carlsberg beer and CopenHill; send an illumina‑resonant hello to Greta. Visit earth.plnt.earth → https://earth.plnt.earth"
        };
      }
    });
  }
  ensureDemo();

  /* Prefill the Notes area one time with Bee note (non‑destructive) */
  (function seedBeeNoteUI(){
    const d = M.DB.get();
    if(d && d.notes && d.notes.bee && !localStorage.getItem("mm.motion.v1.__beeSeeded")){
      UI.els.queueNotes.value = "🐝 Bee note — think about Carlsberg beer and CopenHill; say hi to Greta (she’s gonna save the world). illumina‑resonant.\nLink: https://earth.plnt.earth";
      localStorage.setItem("mm.motion.v1.__beeSeeded","1");
    }
    // Also show a little chip near top:
    const chip = document.createElement("span");
    chip.className="chip editor-only"; chip.style.cursor="pointer";
    chip.innerHTML = '🐝 <strong>Bee</strong> says: think Carlsberg × CopenHill — and <a href="https://earth.plnt.earth" target="_blank" rel="noreferrer noopener">earth.plnt.earth</a>. Hi, Greta!';
    const header = document.querySelector(".header .row");
    if(header) header.appendChild(chip);
  })();

  /* ---------- State for the editor & queue ---------- */
  const S = {
    tracks: [],         // loaded from DB
    currentTrackId:null,
    currentBuffer:null,
    bars:null,          // Float32Array waveform peaks
    queue: [],          // [{type:'range'|'segment', trackId, start, end, segId?, label?, color?}]
    queuePlay:{ playing:false, index:0, timer:null },
    favorites:[],       // slots 1..9 -> segId
  };

  /* ---------- Utility: data: URL -> ArrayBuffer ---------- */
  function dataURLtoArrayBuffer(url){
    try{
      const base64 = url.split(",")[1] || "";
      const bin = atob(base64);
      const len = bin.length;
      const bytes = new Uint8Array(len);
      for(let i=0;i<len;i++) bytes[i] = bin.charCodeAt(i);
      return bytes.buffer;
    }catch(_){ return null; }
  }

  /* ---------- Persistence wiring ---------- */
  function loadFromDB(){
    const d = M.DB.get();
    S.tracks = d.tracks.slice();
    S.favorites = (d.settings && Array.isArray(d.settings.favorites)) ? d.settings.favorites.slice() : [];
  }

  function saveQueueToDB(name){
    const obj = {
      id: "q_"+Date.now(),
      name: name || "Queue "+new Date().toLocaleString(),
      items: S.queue.slice().map(x=> JSON.parse(JSON.stringify(x))),
      notes: UI.els.queueNotes.value || "",
      createdAt: Date.now()
    };
    M.DB.set(d=>{ d.queues.unshift(obj); });
    M.toast("Queue saved");
  }

  function refreshTrackPicker(){
    // populate select
    UI.els.trackPicker.innerHTML = "";
    S.tracks.forEach((t, i)=>{
      const opt = document.createElement("option");
      opt.value = t.id;
      opt.textContent = t.title || ("Track "+(i+1));
      UI.els.trackPicker.appendChild(opt);
    });
  }

  /* ---------- Waveform cache ---------- */
  function getCachedBars(trackId){ try{ const d=M.DB.get(); const c=d.cache && d.cache.waveforms && d.cache.waveforms[trackId]; if(!c) return null; if(!Array.isArray(c.bars)) return null; return new Float32Array(c.bars); }catch(_){ return null; } }
  function setCachedBars(trackId, bars){ M.DB.set(d=>{ d.cache = d.cache||{waveforms:{}}; d.cache.waveforms[trackId] = { bars: Array.from(bars) }; }); }

  /* ---------- Track loading ---------- */
  async function loadTrackById(id){
    const t = S.tracks.find(x=> x.id===id) || S.tracks[0];
    if(!t){ return; }
    S.currentTrackId = t.id;
    UI.els.trackPicker.value = t.id;

    if(t.sourceType === "audio"){
      const arr = dataURLtoArrayBuffer(t.sourceIdOrUrl||"");
      if(!arr){ M.toast("Bad audio data"); return; }
      M.Engine.ensure();
      const buf = await M.Engine.S.ctx.decodeAudioData(arr.slice(0));
      S.currentBuffer = buf;
      M.Engine.loadBuffer(buf, t.id);
      M.Engine.setGainDb(M.DB.get().settings.gainDb|0);
      M.Engine.setTone(!!M.DB.get().settings.tone?.on, M.DB.get().settings.tone?.db|0);
      M.Engine.setCrossfade((M.DB.get().settings.crossfadeMs|0)||25);

      UI.state.duration = buf.duration;
      const cached = getCachedBars(t.id);
      if(cached){ S.bars = cached; M.Wave.draw(UI.els.wave, cached); }
      else{
        const bars = M.Wave.analyzePeaks(buf, 800);
        S.bars = bars; setCachedBars(t.id, bars); M.Wave.draw(UI.els.wave, bars);
      }
      // default range: full
      setRangeAbs(0, buf.duration);
      updateTimeLabels(0);
      updateDisplayHeader();
    }else{
      M.toast("YouTube entry: metadata only (no network).");
    }
  }

  /* ---------- Range helpers ---------- */
  function setRangePct(aPct, bPct){
    aPct = M.clamp(aPct, 0, 1); bPct = M.clamp(bPct, 0, 1);
    UI.state.dragA = Math.min(aPct, bPct - 0.005);
    UI.state.dragB = Math.max(bPct, aPct + 0.005);
    layoutBand(); updateIOFields();
  }
  function setRangeAbs(a, b){
    const dur = UI.state.duration||1;
    setRangePct(a/dur, b/dur);
  }
  function getRangeAbs(){
    const dur = UI.state.duration||1;
    return { a: UI.state.dragA*dur, b: UI.state.dragB*dur };
  }
  function layoutBand(){
    UI.els.hIn.style.left = (UI.state.dragA*100)+"%";
    UI.els.hOut.style.left= (UI.state.dragB*100)+"%";
    UI.els.band.style.left= (UI.state.dragA*100)+"%";
    UI.els.band.style.width=((UI.state.dragB-UI.state.dragA)*100)+"%";
  }
  function updateIOFields(){
    const dur = UI.state.duration||1;
    const a = UI.state.dragA*dur, b=UI.state.dragB*dur;
    UI.els.inTime.value  = toLabel(a);
    UI.els.outTime.value = toLabel(b);
  }
  function toLabel(sec){ sec=Math.max(0, Math.round(sec)); const m=(sec/60)|0, s=(sec%60)|0; return m+":"+(s<10?"0"+s:s); }
  function updateTimeLabels(currentSec){
    const dur = UI.state.duration||1;
    UI.els.timeNow.textContent  = M.fmtTime(currentSec);
    UI.els.timeLeft.textContent = "–"+M.fmtTime(Math.max(0, dur - currentSec));
  }

  /* ---------- Keyboard shortcuts ---------- */
  (function bindKeys(){
    window.addEventListener("keydown", function(e){
      const active = document.activeElement;
      const typing = active && (/(INPUT|TEXTAREA|SELECT)/.test(active.tagName) || active.isContentEditable);
      if(typing) return;

      const k = e.key;
      if(k === " "){ e.preventDefault(); $("#btnPlay").click(); return; }
      if(k === "i"){ e.preventDefault(); markIn(); return; }
      if(k === "o"){ e.preventDefault(); markOut(); return; }
      if(k === "l"){ e.preventDefault(); toggleLoop(); return; }
      if(k === "ArrowLeft"){ e.preventDefault(); nudge(-0.25); return; }
      if(k === "ArrowRight"){ e.preventDefault(); nudge(+0.25); return; }
      if(k === "ArrowUp"){ e.preventDefault(); stepGain(+1); return; }
      if(k === "ArrowDown"){ e.preventDefault(); stepGain(-1); return; }
      if(k === "s"){ e.preventDefault(); saveSegment(); return; }
      if(k === "q"){ e.preventDefault(); addToQueue(); return; }
      if(/^[1-9]$/.test(k)){ e.preventDefault(); jumpFavorite(parseInt(k,10)); return; }
    }, true);
    M.DB.set(d=>{ d.settings.keymapBound = true; });
  })();

  function stepGain(deltaDb){
    const el = UI.els.gainDb; const v = M.clamp((parseInt(el.value,10)||0)+deltaDb, -36, 6);
    el.value = String(v); UI.els.gainDbVal.textContent = v+" dB";
    M.Engine.setGainDb(v); M.DB.set(d=>{ d.settings.gainDb = v; });
  }
  function nudge(sec){
    const dur = UI.state.duration||1;
    const {a,b} = getRangeAbs();
    const mid = (a+b)/2 + sec;
    const span = (b-a)/2;
    const A = M.clamp(mid - span, 0, dur-0.005);
    const B = M.clamp(mid + span, A+0.005, dur);
    setRangeAbs(A,B);
  }

  function markIn(){
    const t = M.Engine.time(); const dur=UI.state.duration||1;
    const a = M.clamp(t/dur, 0, UI.state.dragB-0.005);
    setRangePct(a, UI.state.dragB);
  }
  function markOut(){
    const t = M.Engine.time(); const dur=UI.state.duration||1;
    const b = M.clamp(t/dur, UI.state.dragA+0.005, 1);
    setRangePct(UI.state.dragA, b);
  }
  function toggleLoop(){
    const on = UI.els.btnLoop.getAttribute("aria-pressed")!=="true";
    UI.els.btnLoop.setAttribute("aria-pressed", String(on));
    M.Engine.S.loop.on = on;
  }

  /* ---------- Play/Stop wiring ---------- */
  function playCurrent(){
    if(!M.Engine.S.unlocked){ M.toast("Tap Start to unlock audio"); return; }
    const {a,b} = getRangeAbs();
    const loop = UI.els.btnLoop.getAttribute("aria-pressed")==="true";
    M.Engine.scheduleSegment(a,b,loop);
    UI.els.btnPlay.textContent = "Pause";
  }
  function stopCurrent(){
    M.Engine.stop();
    UI.els.btnPlay.textContent = "Play";
  }

  UI.els.btnPlay.addEventListener("click", ()=>{ if(M.Engine.S.playing) stopCurrent(); else playCurrent(); });
  UI.els.btnLoop.addEventListener("click", toggleLoop);
  UI.els.markIn.addEventListener("click", markIn);
  UI.els.markOut.addEventListener("click", markOut);

  /* ---------- IO fields <-> handles ---------- */
  UI.els.inTime.addEventListener("change", ()=>{ const a = M.parseTime(UI.els.inTime.value); const {b} = getRangeAbs(); setRangeAbs(a, Math.max(b, a+0.005)); });
  UI.els.outTime.addEventListener("change", ()=>{ const b = M.parseTime(UI.els.outTime.value); const {a} = getRangeAbs(); setRangeAbs(Math.min(a, b-0.005), b); });

  /* ---------- Track Picker ---------- */
  UI.els.trackPicker.addEventListener("change", ()=> loadTrackById(UI.els.trackPicker.value));

  /* ---------- Segment Save / Favorites ---------- */
  function saveSegment(){
    const {a,b} = getRangeAbs();
    const st = {
      id: guid(),
      trackId: S.currentTrackId,
      in: a, out: b,
      name: (UI.els.segName.value||"").trim() || (toLabel(a)+" → "+toLabel(b)),
      color: UI.els.segColor.value || "#13c399",
      fav: !!UI.els.favToggle.checked,
      notes: (UI.els.segNotes.value||"").trim(),
      createdAt: Date.now()
    };
    M.DB.set(d=>{ d.segments[st.id] = st; if(st.fav){ // auto‑slot fill
      d.settings.favorites = d.settings.favorites||[];
      for(let i=0;i<9;i++){ if(!d.settings.favorites[i]){ d.settings.favorites[i] = st.id; break; } }
    }});
    M.toast("Segment saved");
    // simple visual: star icon glow via class (we only render stars in queue rows, below)
  }
  UI.els.btnSaveSeg.addEventListener("click", saveSegment);

  function jumpFavorite(n){
    const d = M.DB.get();
    const segId = (d.settings.favorites||[])[n-1];
    if(!segId) { M.toast("Empty favorite slot "+n); return; }
    const seg = d.segments[segId]; if(!seg){ M.toast("Missing favorite"); return; }
    if(seg.trackId && seg.trackId !== S.currentTrackId){ loadTrackById(seg.trackId).then(()=>{ setRangeAbs(seg.in, seg.out); playCurrent(); }); }
    else { setRangeAbs(seg.in, seg.out); playCurrent(); }
  }

  /* ---------- Queue ---------- */
  function renderQueue(){
    const el = UI.els.queue; el.innerHTML = "";
    S.queue.forEach((q, idx)=>{
      const row = document.createElement("div"); row.className="q-item"; row.setAttribute("role","listitem"); row.dataset.idx = String(idx);

      const drag = document.createElement("span"); drag.className="drag chip"; drag.textContent="⠿"; drag.title="Drag to reorder";
      const meta = document.createElement("div"); meta.className="grow q-meta"; meta.innerHTML = `<strong>${q.label||"Range"}</strong> • ${toLabel(q.start)}→${toLabel(q.end)} <span class="chip" style="background:${q.color||'var(--chip)'}; border-color:var(--border)"></span>`;
      const play = document.createElement("button"); play.className="btn ghost"; play.textContent="Play";
      const del = document.createElement("button"); del.className="btn ghost"; del.textContent="Remove";

      play.addEventListener("click", ()=>{ setRangeAbs(q.start, q.end); if(q.trackId && q.trackId!==S.currentTrackId){ loadTrackById(q.trackId).then(playCurrent); } else { playCurrent(); } });
      del.addEventListener("click", ()=>{ S.queue.splice(idx,1); renderQueue(); renderDisplayQueue(); });

      // drag reorder (simple index swap)
      let startY=0, from=idx;
      drag.addEventListener("pointerdown", (e)=>{ drag.setPointerCapture(e.pointerId); startY=e.clientY; from=idx; row.style.opacity=".7"; });
      drag.addEventListener("pointerup",   ()=>{ row.style.opacity=""; });
      drag.addEventListener("pointermove", (e)=>{
        if(!row.style.opacity) return;
        const dy = e.clientY - startY;
        const threshold = 36;
        if(dy > threshold && from < S.queue.length-1){ const t=S.queue[from]; S.queue[from]=S.queue[from+1]; S.queue[from+1]=t; from++; startY=e.clientY; renderQueue(); renderDisplayQueue(); }
        if(dy < -threshold && from > 0){ const t=S.queue[from]; S.queue[from]=S.queue[from-1]; S.queue[from-1]=t; from--; startY=e.clientY; renderQueue(); renderDisplayQueue(); }
      });

      row.append(drag, meta, play, del);
      el.appendChild(row);
    });
  }

  function addToQueue(){
    const {a,b} = getRangeAbs();
    const obj = {
      type:"range", trackId:S.currentTrackId, start:a, end:b,
      label: (UI.els.segName.value||"").trim() || "Range",
      color: UI.els.segColor.value || "#13c399",
      fav: !!UI.els.favToggle.checked
    };
    S.queue.push(obj); renderQueue(); renderDisplayQueue(); M.toast("Added to queue");
  }
  UI.els.btnAddQueue.addEventListener("click", addToQueue);

  UI.els.btnClearQueue.addEventListener("click", ()=>{ S.queue.length=0; renderQueue(); renderDisplayQueue(); });
  UI.els.btnSaveQueue.addEventListener("click", ()=>{
    const name = prompt("Queue name?");
    if(name){ saveQueueToDB(name); }
  });

  // Inject a Play Queue button (UI markup from Part 1 didn’t include it)
  (function injectPlayQueue(){
    const headerBtns = UI.els.btnSaveQueue.parentElement;
    if(!document.getElementById("btnPlayQueue") && headerBtns){
      const b = document.createElement("button");
      b.id="btnPlayQueue"; b.className="btn"; b.textContent="Play Queue";
      headerBtns.prepend(b);
      b.addEventListener("click", playQueue);
    }
  })();

  function playQueue(){
    if(!S.queue.length){ M.toast("Queue empty"); return; }
    S.queuePlay.playing = true; S.queuePlay.index = 0;
    const loopWas = UI.els.btnLoop.getAttribute("aria-pressed")==="true";
    if(loopWas) UI.els.btnLoop.setAttribute("aria-pressed","false");
    function step(){
      if(!S.queuePlay.playing) return;
      const q = S.queue[S.queuePlay.index]; if(!q){ S.queuePlay.playing=false; return; }
      const go = ()=>{ setRangeAbs(q.start, q.end); M.Engine.scheduleSegment(q.start, q.end, false); UI.els.btnPlay.textContent="Pause"; };
      if(q.trackId && q.trackId!==S.currentTrackId){ loadTrackById(q.trackId).then(go); } else { go(); }
      // pre‑schedule next step with tiny overlap to feel gapless
      const durMs = Math.max(0, (q.end - q.start)*1000);
      clearTimeout(S.queuePlay.timer);
      S.queuePlay.timer = setTimeout(()=>{ S.queuePlay.index++; if(S.queuePlay.index < S.queue.length){ step(); }else{ S.queuePlay.playing=false; } }, Math.max(0, durMs - (M.DB.get().settings.crossfadeMs||25)));
    }
    step();
  }

  /* ---------- Notes: simple markdown (*bold* / _italic_) renderer (used in display list) ---------- */
  function mdMini(s){
    if(!s) return "";
    return s.replace(/\*([^*]+)\*/g, "<strong>$1</strong>").replace(/_([^_]+)_/g, "<em>$1</em>");
  }

  /* ---------- Import / Export (root key mm.motion.v1) ---------- */
  UI.els.btnExport.addEventListener("click", ()=>{
    const raw = JSON.stringify(M.DB.get(), null, 2);
    UI.els.jsonArea.value = raw;
  });
  UI.els.btnCopyJson.addEventListener("click", ()=>{
    const txt = UI.els.jsonArea.value||"";
    if(navigator.clipboard && navigator.clipboard.writeText){ navigator.clipboard.writeText(txt); M.toast("Copied"); }
  });
  UI.els.btnLoadJson.addEventListener("click", ()=>{
    try{
      const obj = JSON.parse(UI.els.jsonArea.value||"{}");
      M.DB.write(obj);
      M.toast("Loaded");
      loadFromDB(); refreshTrackPicker(); loadTrackById(S.tracks[0]?.id);
    }catch(_){ M.toast("Bad JSON"); }
  });

  /* ---------- Tracks Manager ---------- */
  function renderTracksList(){
    const list = UI.els.tracksList; list.innerHTML = "";
    S.tracks.forEach((t)=>{
      const row = document.createElement("div"); row.className="q-item"; row.setAttribute("role","listitem");
      row.innerHTML = `<div class="grow">${t.title} <span class="chip">${t.sourceType}</span></div>`;
      const use = document.createElement("button"); use.className="btn"; use.textContent="Use";
      const del = document.createElement("button"); del.className="btn ghost"; del.textContent="Delete";
      use.addEventListener("click", ()=>{ loadTrackById(t.id); M.closeModal(UI.els.tracksModal); });
      del.addEventListener("click", ()=>{ M.DB.set(d=>{ d.tracks = d.tracks.filter(x=> x.id!==t.id); }); loadFromDB(); refreshTrackPicker(); renderTracksList(); });
      row.append(use, del); list.appendChild(row);
    });
  }

  UI.els.btnPickFile.addEventListener("click", ()=> UI.els.trkFile.click());
  UI.els.trkFile.addEventListener("change", ()=>{
    const f = UI.els.trkFile.files && UI.els.trkFile.files[0];
    if(!f) return;
    const rd = new FileReader();
    rd.onload = ()=>{ UI.els.trkSrc.value = String(rd.result||""); };
    rd.readAsDataURL(f);
  });
  UI.els.btnAddTrack.addEventListener("click", ()=>{
    const t = {
      id: "trk_"+Date.now(),
      title: UI.els.trkTitle.value.trim() || "Untitled",
      sourceType: UI.els.trkType.value || "audio",
      sourceIdOrUrl: UI.els.trkSrc.value.trim(),
      durationSec: parseInt(UI.els.trkDur.value||"0",10)||0,
      bpm: parseInt(UI.els.trkBpm.value||"0",10)||0,
      key: UI.els.trkKey.value.trim()||""
    };
    if(!t.sourceIdOrUrl){ M.toast("No source"); return; }
    M.DB.set(d=>{ d.tracks.unshift(t); });
    loadFromDB(); refreshTrackPicker(); renderTracksList(); M.toast("Track added");
    UI.els.trkTitle.value=""; UI.els.trkSrc.value=""; UI.els.trkDur.value=""; UI.els.trkBpm.value=""; UI.els.trkKey.value="";
  });

  /* ---------- Check‑Ins (right panel) ---------- */
  function renderSpark(){
    const arr = (M.DB.get().checkins||[]).map(x=> x.energy).slice(0,64).reverse();
    M.drawSpark(UI.els.ckSpark, arr);
  }
  UI.els.ckLog.addEventListener("click", ()=>{
    const rec = { ts: Date.now(), energy: parseInt(UI.els.ckEnergy.value,10)||0, mood: UI.els.ckMood.value.trim(), body: UI.els.ckBody.value, note: UI.els.ckText.value.trim() };
    M.DB.set(d=>{ d.checkins.unshift(rec); });
    UI.els.ckText.value=""; renderSpark(); M.toast("Logged");
  });
  UI.els.ckExport.addEventListener("click", ()=>{
    const data = JSON.stringify(M.DB.get().checkins||[], null, 2);
    const a = document.createElement("a");
    a.href = "data:application/json;charset=utf-8,"+encodeURIComponent(data);
    a.download="motion_checkins.json"; document.body.appendChild(a); a.click(); a.remove();
  });
  renderSpark();

  /* ---------- Display (Showcase) ---------- */
  function updateDisplayHeader(){
    UI.els.displayNow.textContent = (S.tracks.find(x=>x.id===S.currentTrackId)?.title)||"—";
  }
  function renderDisplayQueue(){
    const el = UI.els.displayQueue; el.innerHTML = "";
    S.queue.forEach(q=>{
      const row = document.createElement("div"); row.className="q-item"; row.innerHTML =
        `<div class="grow">${q.label||"Range"} <span class="chip">${toLabel(q.start)}→${toLabel(q.end)}</span></div>`;
      el.appendChild(row);
    });
  }
  function setDisplay(flag){
    document.body.setAttribute("data-view", flag? "display":"");
    UI.els.btnDisplay.setAttribute("aria-pressed", String(!!flag));
    UI.els.displayMode.textContent = UI.els.btnLoop.getAttribute("aria-pressed")==="true" ? "Loop" : "Whole Set";
    UI.els.displayBadge.innerHTML = M.Engine.S.unlocked ? "<span aria-hidden='true'>🔓</span> Unlocked" : "<span aria-hidden='true'>🔒</span> Locked";
  }
  UI.els.btnDisplay.addEventListener("click", ()=> setDisplay(document.body.getAttribute("data-view")!=="display"));
  UI.els.btnExitDisplay.addEventListener("click", ()=> setDisplay(false));
  UI.els.btnLock.addEventListener("click", ()=>{
    const locked = document.body.getAttribute("data-locked")==="true";
    document.body.setAttribute("data-locked", String(!locked));
  });

  /* ---------- Top tabs (modes) ---------- */
  function setTabPressed(which){
    [UI.els.tabGreens, UI.els.tabWhole, UI.els.tabLab, UI.els.tabShow].forEach(b=> b.setAttribute("aria-pressed", String(b===which)));
  }
  UI.els.tabGreens.addEventListener("click", ()=>{
    setTabPressed(UI.els.tabGreens);
    document.documentElement.setAttribute("data-theme","motion-greens");
    M.DB.set(d=>{ d.settings.theme="motion-greens"; });
    M.toast("Motion greens on");
  });
  UI.els.tabWhole.addEventListener("click", ()=>{
    setTabPressed(UI.els.tabWhole);
    setRangeAbs(0, UI.state.duration||1);
    UI.els.btnLoop.setAttribute("aria-pressed","false");
    M.toast("Whole set");
  });
  UI.els.tabLab.addEventListener("click", ()=>{
    setTabPressed(UI.els.tabLab);
    try{ UI.els.inTime.focus(); }catch(_){}
  });
  UI.els.tabShow.addEventListener("click", ()=>{
    setTabPressed(UI.els.tabShow); setDisplay(true);
  });

  /* ---------- Timer/Playhead text updates ---------- */
  M.Clock.on(()=>{ updateTimeLabels(M.Engine.time()); });

  /* ---------- Self‑Check ---------- */
  async function runSelfCheck(){
    // 1) AudioContext unlocked
    const okUnlock = await M.Engine.unlock();
    M.setCheckRow("ctx", "AudioContext unlocked", okUnlock?"ok":"bad", okUnlock?"":"Tap Start on iOS");

    // 2) Play/pause without exceptions (short slice)
    let okPlay = false;
    try{
      if(!M.Engine.S.track.buffer && S.currentBuffer){ M.Engine.loadBuffer(S.currentBuffer, S.currentTrackId); }
      const dur = UI.state.duration||1;
      const a = Math.max(0, (dur*0.1)|0), b=Math.min(dur, a + 0.25);
      M.Engine.scheduleSegment(a,b,false);
      okPlay = true;
    }catch(_){ okPlay = false; }
    M.setCheckRow("play", "Play/Pause basic", okPlay?"ok":"bad");
    setTimeout(()=>{ M.Engine.stop(); }, 260);

    // 3) Loop obeys In/Out with crossfade
    let okLoop=true;
    try{
      M.Engine.setCrossfade( M.DB.get().settings.crossfadeMs || 25 );
      const dur = UI.state.duration||1;
      const a = Math.max(0, (dur*0.2)|0), b=Math.min(dur, a + 0.35);
      M.Engine.scheduleSegment(a,b,true);
    }catch(_){ okLoop=false; }
    setTimeout(()=>{ if(!M.Engine.S.playing) okLoop=false; M.Engine.stop(); M.setCheckRow("loop", "Loop / crossfade", okLoop?"ok":"warn"); }, 420);

    // 4) localStorage R/W
    let okLS=false; try{ localStorage.setItem("__mm_test","1"); okLS = localStorage.getItem("__mm_test")==="1"; localStorage.removeItem("__mm_test"); }catch(_){ okLS=false; }
    M.setCheckRow("ls", "localStorage R/W", okLS?"ok":"bad");

    // 5) Keyboard map active
    const mapActive = !!M.DB.get().settings.keymapBound;
    M.setCheckRow("keymap", "Keyboard active", mapActive?"ok":"warn", "Shortcuts disabled in text fields");

    // 6) Prefers‑reduced‑motion honored
    const prm = !!M.DB.get().settings.reducedMotion;
    M.setCheckRow("prm", "prefers‑reduced‑motion", prm?"ok":"warn");
  }
  $("#btnSelf, #btnSelfFloat").addEventListener("click", runSelfCheck);

  /* ---------- Init ---------- */
  loadFromDB();
  refreshTrackPicker();
  loadTrackById(S.tracks[0]?.id || "demo_tone");

  /* ---------- Tiny helpers ---------- */
  function $(sel, root=document){ return root.querySelector(sel); }

  // Update display timer every second for showcase
  (function dispTick(){
    UI.els.displayTimer.textContent = M.fmtTime(M.Engine.time());
    requestAnimationFrame(dispTick);
  })();

  // Resize waveform on window resize
  window.addEventListener("resize", ()=>{ if(S.bars) M.Wave.draw(UI.els.wave, S.bars); });

  // Ensure focus
  (function ensureFocus(){ try{ document.body.focus({preventScroll:true}); }catch(_){ } })();

})();
</script>

<!--
ACCEPTANCE TESTS (inline checklist)
1) Create a segment (set In/Out) → name → star → loop with seamless cross‑fade.
2) Add 3 segments to queue → drag‑reorder (⠿ handle) → Play Queue → gapless transitions.
3) Toggle Tone overlay (checkbox) → adjust slider → reload page → setting persists.
4) Save a note on a segment (notes field) → reload → segment notes still present.
5) Run ✓ Self‑Check → all green on desktop + iOS Safari (tap Start to unlock).
6) Export JSON → reload → Import JSON (paste into modal) → full state restored.
-->

</body>
</html>




